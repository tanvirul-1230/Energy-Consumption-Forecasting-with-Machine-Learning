import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from xgboost import XGBRegressor
from sklearn.metrics import mean_squared_error, r2_score
import os

# --- Configuration ---
DATA_PATH_ENERGY = 'AEP_hourly.csv'
DATA_PATH_WEATHER = 'weather_data/'
WEATHER_CITY = 'Indianapolis' # Using Indianapolis as it's in the AEP area and in the dataset
TARGET = 'AEP_MW'

def load_energy_data(path):
    """Loads, cleans, and resamples the AEP energy data."""
    print(f"Loading energy data from {path}...")
    try:
        df_energy = pd.read_csv(path)
    except FileNotFoundError:
        print(f"Error: Energy data file not found at {path}")
        return None
    
    df_energy['Datetime'] = pd.to_datetime(df_energy['Datetime'])
    df_energy = df_energy.set_index('Datetime')
    # Resample to 'h' (hourly) to ensure consistent timestamps and fix warning
    df_energy = df_energy.resample('h').mean() 
    df_energy = df_energy.ffill() # Forward-fill missing values
    return df_energy

def clean_weather_df(df, city_name, col_name):
    """Helper function to clean a single weather file."""
    if city_name not in df.columns:
        print(f"Error: City '{city_name}' not in weather file. Check name.")
        return None
    
    df_city = df[['datetime', city_name]].copy()
    df_city['datetime'] = pd.to_datetime(df_city['datetime'])
    df_city = df_city.set_index('datetime')
    df_city = df_city.resample('h').mean()
    df_city = df_city.rename(columns={city_name: col_name})
    return df_city

def load_weather_data(path, city):
    """Loads and merges temperature and humidity data for a specific city."""
    print(f"Loading weather data from {path} for city: {city}...")
    try:
        df_temp = pd.read_csv(os.path.join(path, 'temperature.csv'))
        df_humid = pd.read_csv(os.path.join(path, 'humidity.csv'))
    except FileNotFoundError:
        print(f"Error: Weather files not found in {path}")
        return None

    # Clean both dataframes
    df_temp_clean = clean_weather_df(df_temp, city, 'temperature')
    df_humid_clean = clean_weather_df(df_humid, city, 'humidity')

    if df_temp_clean is None or df_humid_clean is None:
        return None

    # Join them
    df_weather = df_temp_clean.join(df_humid_clean)
    
    # Convert Temp from Kelvin to Celsius (more interpretable)
    df_weather['temperature_c'] = df_weather['temperature'] - 273.15
    df_weather = df_weather.drop(columns=['temperature'])
    return df_weather

def create_time_features(df_in):
    """Creates time-series features from a datetime index."""
    print("Engineering time-based features...")
    df_out = df_in.copy()
    df_out['hour'] = df_out.index.hour
    df_out['day_of_week'] = df_out.index.dayofweek
    df_out['month'] = df_out.index.month
    df_out['quarter'] = df_out.index.quarter
    df_out['day_of_year'] = df_out.index.dayofyear
    return df_out

def create_lag_features(df_in):
    """Creates lag and rolling-window features."""
    print("Engineering lag and rolling features...")
    df_out = df_in.copy()
    
    # Lag features (past values)
    df_out['lag_24h'] = df_out[TARGET].shift(24)
    df_out['lag_1w'] = df_out[TARGET].shift(24 * 7)
    
    # Rolling features (recent trend)
    df_out['rolling_6h_mean'] = df_out[TARGET].shift(1).rolling(window=6).mean()
    
    return df_out

def main():
    """Main function to run the forecasting pipeline."""
    
    # --- 1. Load Data ---
    df_energy = load_energy_data(DATA_PATH_ENERGY)
    df_weather = load_weather_data(DATA_PATH_WEATHER, WEATHER_CITY)
    
    if df_energy is None or df_weather is None:
        print("Failed to load data. Exiting.")
        return

    # --- 2. Merge Data ---
    print("Merging energy and weather data...")
    # 'inner' join keeps only timestamps present in both datasets
    df_combined = df_energy.join(df_weather, how='inner')
    df_combined = df_combined.ffill() # Fill any gaps from merge
    
    # --- 3. Feature Engineering ---
    df_features = create_time_features(df_combined)
    df_features = create_lag_features(df_features)
    
    # Drop all rows with NaN (from lags/rolling)
    df_features = df_features.dropna()
    
    # --- 4. Define Features (X) and Target (y) ---
    FEATURES = [
        'hour', 'day_of_week', 'month', 'quarter', 'day_of_year',
        'lag_24h', 'lag_1w',
        'rolling_6h_mean',
        'temperature_c',
        'humidity'
    ]
    
    X = df_features[FEATURES]
    y = df_features[TARGET]
    
    # --- 5. Train/Test Split ---
    # For time-series, we MUST split by date, not randomly.
    print("Splitting data into train and test sets...")
    test_size = 24 * 30 * 6  # 6 months of hourly data for testing
    X_train = X.iloc[:-test_size]
    y_train = y.iloc[:-test_size]
    X_test = X.iloc[-test_size:]
    y_test = y.iloc[-test_size:]

    print(f"Training data shape: {X_train.shape}")
    print(f"Test data shape: {X_test.shape}")
    
    # --- 6. Train Model ---
    print("Training XGBoost model...")
    model = XGBRegressor(
        n_estimators=1000,
        learning_rate=0.01,
        random_state=42,
        n_jobs=-1,
        early_stopping_rounds=50 # Stop if no improvement
    )
    
    model.fit(X_train, y_train,
              eval_set=[(X_test, y_test)],
              verbose=100)
    
    # --- 7. Evaluate Model ---
    print("\nEvaluating model...")
    y_pred = model.predict(X_test)
    
    rmse = np.sqrt(mean_squared_error(y_test, y_pred))
    r2 = r2_score(y_test, y_pred)
    
    print("--- Model Evaluation (Test Set) ---")
    print(f"  Root Mean Squared Error (RMSE): {rmse:.2f} MW")
    print(f"  R-squared (R²): {r2:.2f}")
    
    # --- 8. Visualize and Save Plot ---
    print("Saving prediction plot as 'prediction_plot.png'...")
    plot_len = 24 * 7  # Plot one week
    
    plt.figure(figsize=(15, 6))
    plt.plot(y_test.index[:plot_len], y_test.values[:plot_len], 
             label='Actual Consumption', color='blue', linewidth=2)
    plt.plot(y_test.index[:plot_len], y_pred[:plot_len], 
             label='Predicted Consumption', color='red', linestyle='--', linewidth=2)
    plt.xlabel('Datetime')
    plt.ylabel('Energy Consumption (MW)')
    plt.title(f'Energy Consumption: Actual vs. Predicted (R²: {r2:.2f})')
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.savefig('prediction_plot.png')
    
    print("\nProject pipeline complete.")

if __name__ == "__main__":
    main()
